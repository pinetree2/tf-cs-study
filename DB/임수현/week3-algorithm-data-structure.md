# [ week3 ] 알고리즘, 자료구조


<details>
<summary>BigO란 무엇인가?</summary><hr>

Big O 표기법은 알고리즘의 성능을 평가하는데 사용되는 표기법입니다.  
이는 알고리즘의 시간 복잡도와 공간 복잡도를 나타내며, 알고리즘이 입력 크기에 따라 얼마나 빨리 실행되는지 또는 얼마나 많은 자원을 사용하는지를 설명합니다.  
Big O는 주로 최악의 경우 시나리오를 기준으로 하며, 입력 크기에 대한 알고리즘의 성능을 추정하는 데 사용됩니다.  
이를 통해 다양한 알고리즘 간의 효율성을 비교하고 최적의 알고리즘을 선택할 수 있습니다.

</details>



<details>
<summary>DFS와 BFS의 차이에 대해서 설명해주세요.</summary><hr>

DFS(Depth-First Search, 깊이 우선 탐색)와 BFS(Breadth-First Search, 너비 우선 탐색)는 그래프를 탐색하는 두 가지 주요 알고리즘입니다.  
DFS는 그래프를 깊이 방향으로 탐색하는 반면, BFS는 너비 방향으로 탐색합니다.  
DFS는 한 노드의 모든 자식을 탐색한 후 그 자식의 자식을 탐색하고, 그 과정을 반복합니다. 반면에 BFS는 한 노드의 모든 이웃을 먼저 탐색한 후 그 이웃의 이웃을 탐색합니다.  
이러한 차이로 인해 DFS는 스택을 사용하여 구현되고, BFS는 큐를 사용하여 구현됩니다.  
DFS는 그래프에서 깊은 부분을 먼저 탐색하므로 메모리 사용이 더 적지만, BFS는 가까운 부분부터 탐색하므로 최단 경로를 찾는 데 유용합니다.

</details>



<details>
<summary>Fibonacci에서의 세 가지(Recursion, Dynamic Programming, 반복) 방식에 대한 시간복잡도와 공간복잡도 차이</summary><hr>

피보나치 수열을 구하는 세 가지 방식인 재귀, 동적 계획법, 반복은 각각 다른 시간복잡도와 공간복잡도를 가집니다.   
재귀 방식은 입력 크기에 따라 지수적으로 증가하는 시간과 공간을 요구하지만,  
동적 계획법과 반복은 선형 시간복잡도를 가지며, 공간 요구량도 상대적으로 적습니다.  
이에 따라 동적 계획법과 반복 방식이 피보나치 수열을 구하는 데 효율적인 방법입니다. 

> 피보나치 수열을 구하는 세 가지 방식인 재귀(Recursion), 동적 계획법(Dynamic Programming), 그리고 반복(Iteration) 방식은 각각 다른 시간복잡도와 공간복잡도를 가지고 있습니다.
> 1. 재귀 방식: 
> <br> - 시간복잡도: 지수 시간복잡도를 가집니다. 재귀 호출에 의해 중복 계산이 많아지므로, 입력 크기에 따라 지수적으로 시간이 증가합니다.
> <br> - 공간복잡도: 재귀 호출에 의해 스택 메모리가 쌓이므로, 재귀 호출의 깊이에 비례하여 공간이 증가합니다.
> 2. 동적 계획법 방식:
> <br> - 시간복잡도: 선형 시간복잡도를 가집니다. 이미 계산된 결과를 배열에 저장하고 재활용하기 때문에 중복 계산을 피할 수 있습니다.
> <br> - 공간복잡도: 추가적인 배열이 필요하므로, 입력 크기에 비례하여 공간을 사용합니다.
> 3. 반복 방식:
> <br> - 시간복잡도: 선형 시간복잡도를 가집니다. 이전 결과를 이용하여 다음 결과를 계산하므로, 반복문의 횟수에 비례하여 시간이 증가합니다.
> <br> - 공간복잡도: 별도의 배열이나 변수가 필요하지 않으므로, 추가적인 공간을 사용하지 않습니다.
> 이와 같이, 세 가지 방식의 시간복잡도와 공간복잡도는 각각 재귀 방식이 가장 비효율적이고, 동적 계획법과 반복 방식이 효율적입니다. 따라서, 피보나치 수열을 구하는 문제에서는 재귀보다는 동적 계획법이나 반복을 사용하는 것이 성능상 더 효율적입니다.

</details>



<details>
<summary>정렬 알고리즘의 종류와 개념에 대해서 설명해주세요.</summary><hr>

정렬 알고리즘에는 여러 종류가 있으며, 그 중에서 가장 널리 사용되는 알고리즘은 다음과 같습니다.

1. **버블 정렬 (Bubble Sort)**: 인접한 두 원소를 비교하며 교환하는 방식으로 정렬하는 알고리즘입니다. 시간 복잡도는 \(O(n^2)\)입니다.

2. **선택 정렬 (Selection Sort)**: 주어진 리스트에서 최솟값을 찾아 해당 위치로 이동시키는 과정을 반복하여 정렬하는 알고리즘입니다. 시간 복잡도는 \(O(n^2)\)입니다.

3. **삽입 정렬 (Insertion Sort)**: 리스트를 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분의 원소를 정렬된 부분에 삽입하는 방식으로 정렬하는 알고리즘입니다. 시간 복잡도는 \(O(n^2)\)입니다.

4. **퀵 정렬 (Quick Sort)**: 피벗(pivot)을 기준으로 리스트를 두 개의 부분으로 나누고, 각 부분을 재귀적으로 정렬하는 방식으로 정렬하는 알고리즘입니다. 시간 복잡도는 평균적으로 \(O(n \log n)\)이지만, 최악의 경우 \(O(n^2)\)입니다.

5. **병합 정렬 (Merge Sort)**: 리스트를 반으로 나눈 뒤 각 부분을 재귀적으로 정렬하고, 정렬된 부분을 병합하여 정렬하는 알고리즘입니다. 시간 복잡도는 항상 \(O(n \log n)\)입니다.

6. **힙 정렬 (Heap Sort)**: 힙(heap) 자료구조를 이용하여 정렬하는 알고리즘으로, 시간 복잡도는 \(O(n \log n)\)입니다.

각 정렬 알고리즘은 서로 다른 원리와 방식을 가지고 있으며, 입력 데이터의 크기와 특성에 따라 적합한 알고리즘을 선택하여 사용해야 합니다.

</details>



<details>
<summary>Greedy 알고리즘이란?</summary><hr>

Greedy 알고리즘은 각 단계에서 최선의 선택을 하는 알고리즘입니다.  
이 알고리즘은 매 순간 최적의 해답을 선택하여 전체적으로도 최적의 해답을 찾는 방법입니다.  
즉, 각 단계에서 지금 당장 가장 좋은 선택을 하는 것이 목표입니다.  
Greedy 알고리즘은 항상 최적의 해를 보장하지 않을 수 있지만, 때로는 간단하고 효율적인 해결책을 제공합니다.

</details>



<details>
<summary>최소 신장 트리(MST, Minimum Spanning Tree)란?</summary><hr>

최소 신장 트리(MST, Minimum Spanning Tree)는 그래프에서 간선의 가중치 합이 최소인 트리를 의미합니다.  
이는 그래프의 모든 정점을 연결하면서도 사이클이 없는 부분 그래프를 말합니다.  
최소 신장 트리는 네트워크 디자인이나 회로 연결과 같은 다양한 분야에서 사용되며,  
크루스칼(Kruskal) 알고리즘과 프림(Prim) 알고리즘이 그것을 찾아내는 대표적인 방법입니다..

</details>



<details>
<summary>Kruskal MST 알고리즘이란?</summary><hr>

Kruskal 알고리즘은 최소 신장 트리(Minimum Spanning Tree, MST)를 찾는 알고리즘 중 하나입니다.  
이 알고리즘은 그래프의 모든 간선을 가중치의 오름차순으로 정렬한 후, 가중치가 작은 간선부터 선택하여 사이클을 형성하지 않으면 해당 간선을 MST에 추가합니다. 이 과정을 반복하여 모든 정점을 포함하면서 최소한의 비용으로 연결된 트리를 찾습니다.  
Kruskal 알고리즘은 Greedy 알고리즘의 일종으로,  
시간 복잡도는 O(ElogE)로 알려져 있습니다. 여기서 E는 간선의 수를 나타냅니다.

</details>



<details>
<summary>Prim MST 알고리즘이란?</summary><hr>

Prim 알고리즘은 최소 신장 트리(Minimum Spanning Tree, MST)를 찾는 알고리즘 중 하나입니다.  
이 알고리즘은 특정 정점을 시작으로 그래프의 연결된 부분집합을 확장하면서 MST를 구축합니다. 시작 정점을 기준으로 해당 정점과 연결된 간선 중에서 가장 가중치가 작은 간선을 선택하고, 이에 연결된 정점을 MST에 추가합니다. 그리고 이후 추가된 정점에서부터 다시 가장 작은 가중치의 간선을 선택하여 MST를 확장하는 과정을 반복합니다.  
Prim 알고리즘은 간선을 정렬할 필요가 없으며, 주어진 그래프에서 시작 정점을 선택하는 방법에 따라 다양한 변형이 가능합니다.  
이 알고리즘의 시간 복잡도는 보통 O(V^2) 또는 O(ElogV)입니다. 여기서 V는 그래프의 정점 수를 나타내고, E는 간선의 수를 나타냅니다.

</details>



<details>
<summary>본인이 사용하는 언어의 sort 함수 내부 작동 알고리즘에 대해 설명해주세요.</summary><hr>

각 언어에서 제공하는 정렬 함수의 내부 작동 알고리즘은 다양합니다.

1. Java  
: Java에서는 Arrays 클래스의 sort 메서드나 Collections 클래스의 sort 메서드를 사용하여 배열 또는 컬렉션을 정렬할 수 있습니다. Java의 정렬 알고리즘은 대부분 퀵 정렬(Quicksort)과 병합 정렬(Mergesort)을 기반으로 구현되어 있습니다. 작은 배열에서는 퀵 정렬을 사용하고, 큰 배열에서는 병합 정렬을 사용하여 성능을 최적화합니다.

2. C, C++  
: C와 C++에서는 표준 라이브러리인 <algorithm> 헤더의 sort 함수를 사용하여 정렬할 수 있습니다. 표준 라이브러리의 sort 함수는 일반적으로 퀵 정렬, 힙 정렬(Heapsort), 또는 삽입 정렬(Insertion sort) 중 하나를 사용합니다. 각 컴파일러 및 라이브러리 구현체마다 다를 수 있으나 대부분의 경우 퀵 정렬이나 힙 정렬이 주로 사용됩니다.

3. Python  
: Python의 내장 함수인 sorted() 및 리스트의 sort() 메서드는 팀소트(Timsort) 알고리즘을 기반으로 동작합니다. 팀소트는 삽입 정렬과 병합 정렬을 결합하여 구현된 안정적인 정렬 알고리즘입니다. 팀소트는 최선의 경우 O(nlogn), 최악의 경우 O(nlogn)의 시간 복잡도를 가지며, 대부분의 실제 상황에서 효율적으로 동작합니다.

</details>



<details>
<summary>Trie 알고리즘이란?</summary><hr>

Trie(트라이) 알고리즘은 문자열을 저장하고 검색하는 트리 형태의 자료구조로, 각 문자열을 문자 단위로 트리에 저장합니다.  
Trie(트라이) 알고리즘은 각 노드가 문자를 나타내며, 루트 노드부터 특정 문자열의 각 문자를 따라 내려가며 단어를 저장합니다.  
이를 통해 Trie(트라이) 알고리즘은 메모리를 효율적으로 사용하면서도 빠른 검색 속도를 제공합니다.  
따라서 Trie(트라이) 알고리즘은 문자열 검색, 자동 완성, 철자 검사 등의 다양한 응용 프로그램에서 활용될 수 있습니다.  
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/375px-Trie_example.svg.png">

</details>



<details>
<summary>스택과 큐에 대해 설명하세요.</summary><hr>

스택과 큐는 자료를 저장하고 처리하는 데 사용되는 자료 구조입니다. 스택은 Last-In, First-Out(LIFO) 방식으로 동작하며, 데이터를 넣는 연산을 push, 데이터를 빼내는 연산을 pop이라고 합니다. 즉, 가장 최근에 추가된 항목이 가장 먼저 제거됩니다.  
반면에 큐는 First-In, First-Out(FIFO) 방식으로 동작하며, 데이터를 넣는 연산을 enqueue, 데이터를 빼내는 연산을 dequeue라고 합니다. 따라서 가장 먼저 추가된 항목이 가장 먼저 제거됩니다.  
스택은 함수 호출이나 재귀 알고리즘 등에서 주로 사용되며, 큐는 대기열 관리나 BFS(Breadth-First Search) 알고리즘 등에 주로 활용됩니다.

</details>



<details>
<summary>그래프와 트리 각각의 개념과 차이에 대해 설명해주세요.</summary><hr>

그래프와 트리는 둘 다 자료 구조로서 사용됩니다.  
그래프는 노드(또는 정점)와 간선으로 이루어진 집합으로, 간선이 노드 간의 관계를 나타냅니다. 그래프에는 사이클이 존재할 수 있습니다. 
반면에 트리는 그래프의 한 종류로, 사이클이 없는 그래프입니다. 트리는 뿌리(루트) 노드에서 시작하여 잎(리프) 노드까지 이어지는 계층적 구조를 가지며, 각 노드는 하나의 부모 노드와 여러 개의 자식 노드를 가질 수 있습니다. 

</details>



<details>
<summary>RAID란?</summary><hr>

**RAID는 여러 개의 하드 디스크 드라이브를 하나로 묶어서 데이터를 관리하는 기술**입니다. RAID를 사용하면 데이터가 여러 디스크에 분산되어 저장되므로 성능과 안정성이 향상됩니다. 각각의 RAID 레벨은 데이터를 저장하는 방식에 따라 다르며, 가장 일반적인 RAID 레벨은 RAID 0, RAID 1, RAID 5, RAID 6 등이 있습니다. 

**RAID 0**은 데이터를 여러 디스크에 분산하여 저장하여 성능을 향상시키지만, 하나의 디스크에 장애가 발생하면 모든 데이터가 손실될 수 있습니다.  
**RAID 1**은 미러링 기술을 사용하여 데이터를 복제하여 안정성을 높입니다. 한 디스크에 장애가 발생해도 데이터가 다른 디스크에 복사되어 있으므로 안전합니다.  
**RAID 5와 RAID 6**는 패리티 비트를 사용하여 데이터의 일부를 복구할 수 있는 기술을 제공합니다. 이러한 RAID 레벨은 성능과 안정성을 균형있게 제공합니다.

RAID 기술은 주로 서버 및 데이터 스토리지 시스템에서 사용되며, 하드 디스크의 장애에 대비하여 데이터를 보호하고 읽기/쓰기 성능을 향상시킵니다.

</details>



<details>
<summary>Stack과 Queue, Tree와 Heap의 구조에 대해 설명해주세요.</summary><hr>

### Stack(스택) 
- 구조:
  - 후입선출(LIFO, Last-In-First-Out) 구조로, 새로운 요소는 항상 최상위(top)에 삽입되고 제거됨.
  - 주요 연산: push(삽입), pop(삭제), peek(최상위 요소 확인)
- 시간복잡도:
  - 삽입(입력): O(1)
  - 삭제(출력): O(1)
  - 탐색(최상위 요소 접근): O(1)
- 활용 예시:
  - 함수 호출의 임시 데이터 저장
  - 괄호 짝 검사
  - 웹 브라우저의 뒤로가기 기능 구현

### Queue(큐)
- 구조:
  - 선입선출(FIFO, First-In-First-Out) 구조로, 새로운 요소는 항상 뒤쪽(rear)에 삽입되고 제거됨.
  - 주요 연산: enqueue(삽입), dequeue(삭제), front(첫 번째 요소 확인), rear(마지막 요소 확인)
- 시간복잡도:
  - 삽입(입력): O(1)
  - 삭제(출력): O(1)
  - 탐색(첫 번째 요소 접근): O(1)
- 활용 예시:
  - 작업 대기열(프로세스 스케줄링)
  - BFS(Breadth-First Search) 그래프 탐색
  - 버퍼(입출력 장치 간의 데이터 전달)

### Tree(트리) 
- 구조:
  - 계층적인 구조로, 부모와 자식 노드 간의 관계를 가짐.
  - 각 노드는 하나의 부모 노드와 여러 개의 자식 노드를 가질 수 있음.
  - 이진 트리, 이진 탐색 트리, AVL 트리, 레드-블랙 트리 등 다양한 종류가 있음.
- 시간복잡도:
  - 삽입(Insertion): 일반적으로 O(log n) ~ O(n)의 시간복잡도를 가짐.
  - 삭제(Deletion): 삽입과 동일한 시간복잡도를 가짐.
  - 탐색(Search): 이진 탐색 트리의 경우 O(log n)의 시간복잡도를 가짐.
- 활용 예시:
  - 디렉토리 구조
  - 상속 관계 표현
  - 데이터베이스 인덱스 구현

### Heap(힙)
- 구조:
  - 부모 노드의 값이 항상 자식 노드의 값보다 크거나(최대 힙) 작은(최소 힙) 이진 트리.
  - 보통 배열을 사용하여 구현되며, 부모와 자식 노드의 관계를 표현하기 위해 추가적인 조건이 필요함.
- 시간복잡도:
  - 삽입(Insertion): O(log n)
  - 삭제(Deletion): O(log n)
  - 최소값 또는 최대값 찾기: O(1)
- 활용 예시:
  - 우선순위 큐(Priority Queue)
  - 힙 정렬(Heap Sort)
  - Dijkstra 알고리즘

</details>



<details>
<summary>Stack과 Queue의 실사용 예를 들어 간단히 설명해주세요.</summary><hr>

**Stack 실사용 예**
- 웹 브라우저의 뒤로가기 기능: 사용자가 링크를 클릭할 때마다 해당 페이지의 URL을 스택에 push하여 이전 페이지로 돌아갈 때 pop하여 사용됩니다.
- 실행 취소 기능: 텍스트 편집기에서 사용자가 입력한 텍스트나 작업이 스택에 저장되어 실행 취소를 하면 스택에서 최근 작업이 제거됩니다.
- 함수 호출과 복귀: 함수 호출 시 호출된 함수의 정보(매개변수, 지역 변수 등)가 스택에 push되고, 함수가 종료되면 pop하여 이전 상태로 복귀합니다.

**Queue 실사용 예**
- 프린터의 작업 대기열: 여러 사용자가 프린터에 출력 작업을 요청하면 이를 큐에 enqueue하여 순서대로 출력을 처리합니다.
- BFS(Breadth-First Search) 알고리즘: 그래프의 모든 정점을 방문하기 위해 사용되며, 정점을 방문한 후 인접한 정점을 큐에 enqueue하여 너비 우선으로 탐색합니다.
- 대기열: 은행에서 대기중인 고객이나 온라인 쇼핑몰의 주문이 처리되는 대기열은 큐로 구현됩니다. 새로운 요청은 큐의 뒤쪽에 추가되고, 처리되는 요청은 앞쪽에서 제거됩니다.
- 프로세스 스케줄링: 운영체제에서 다중 프로세스를 관리할 때 프로세스들이 CPU를 사용하는 순서를 결정하기 위해 큐가 사용됩니다.

</details>



<details>
<summary>Priority Queue(우선순위 큐)에 대해 설명해주세요.</summary><hr>

**우선순위 큐**는 일반적인 큐와는 다르게 각 요소에 우선순위가 할당되어 있어, 우선순위가 높은 요소가 먼저 처리되는 자료구조입니다.  
우선순위 큐는 일반적으로 최소 힙(min heap) 또는 최대 힙(max heap)과 같은 트리 구조로 구현됩니다.  
최소 힙에서는 우선순위가 낮은 요소가 먼저 처리되고, 최대 힙에서는 우선순위가 높은 요소가 먼저 처리됩니다.  
이러한 특성으로 우선순위 큐는 주로 작업 스케줄링, 네트워크 라우팅, 이벤트 처리 등 다양한 응용 분야에서 사용됩니다.

</details>



<details>
<summary>Stack 클래스를 손코딩으로 구현해주세요.</summary><hr>

해당 코드는 파이썬으로 작성된 간단한 스택 클래스입니다. 스택은 리스트를 내부 저장소로 사용하여 구현되었습니다. `push` 메서드는 스택에 항목을 추가하고, `pop` 메서드는 최상위 항목을 제거하고 반환합니다. `peek` 메서드는 최상위 항목을 제거하지 않고 반환합니다. `is_empty` 메서드는 스택이 비어 있는지 여부를 확인하고, `size` 메서드는 스택의 크기를 반환합니다.

```python
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        else:
            return "Stack is empty"

    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        else:
            return "Stack is empty"

    def size(self):
        return len(self.items)
```

</details>



<details>
<summary>해시 테이블(Hash Table)과 시간 복잡도에 대해 설명해주세요.</summary><hr>

해시 테이블은 키(Key)와 값(Value)의 쌍을 저장하는 자료구조로, 키를 해시 함수를 사용하여 배열의 인덱스로 변환하여 값을 저장하고 검색합니다.  
이는 빠른 검색과 삽입을 가능하게 하며, 평균적으로 O(1)의 시간 복잡도를 가집니다.  
그러나 충돌(Collision)이 발생할 수 있고, 충돌을 해결하기 위한 방법에 따라 성능이 달라집니다. 최선의 경우 충돌이 없을 때 O(1)의 성능을 보이지만, 최악의 경우 충돌이 많이 발생하면 O(n)의 성능을 보일 수 있습니다.  
이러한 충돌을 해결하기 위해 체이닝(Chaining) 또는 개방 주소법(Open Addressing) 등의 기법을 사용합니다.

</details>


