# [ week3 ] 데이터베이스


<details>
<summary>데이터베이스의 특징에 대해 설명해주세요.</summary><hr>

데이터베이스는 정보를 체계적으로 저장, 관리, 검색할 수 있는 시스템으로, 주요 특징은 다음과 같습니다.  
우선, 데이터베이스는 **자료의 중복을 최소화**하여 데이터 일관성을 유지하며, **데이터와 응용 프로그램을 독립**시켜 데이터 구조 변경에 유연성을 제공합니다.  
또한 데이터베이스는 **보안 기능**을 통해 불법적인 접근과 데이터 손상을 방지하고, **동시성 제어**를 통해 여러 사용자가 동시에 안전하게 데이터에 접근할 수 있도록 합니다.   
마지막으로, 데이터베이스는 **데이터의 일관성과 무결성을 유지**하여 신뢰할 수 있는 정보를 제공합니다.

</details>



<details>
<summary>데이터베이스 언어(DDL,DML,DCL) 에 대해 설명하라</summary><hr>

데이터베이스 언어는 데이터베이스를 다루는 데 사용되는 언어로, 주로 세 가지 유형으로 구분됩니다.  
**DDL (Data Definition Language)은** 주로 **테이블을 생성, 수정, 삭제**하는 데에 사용됩니다. 대표적인 DDL 명령어로는 CREATE, ALTER, DROP 등이 있습니다. 예를 들어, CREATE TABLE 문을 사용하여 새로운 테이블을 생성할 수 있습니다.  
**DML (Data Manipulation Language)은** 주로 **테이블 내의 데이터를 조회, 삽입, 수정, 삭제**하는 데 사용됩니다. 대표적인 DML 명령어로는 SELECT, INSERT, UPDATE, DELETE 등이 있습니다. 예를 들어, INSERT INTO 문을 사용하여 새로운 데이터를 테이블에 추가할 수 있습니다.  
**DCL (Data Control Language)은** 주로 **데이터베이스에 대한 접근 권한을 제어**하는 데 사용됩니다. 주로 데이터베이스의 보안 및 권한 관리에 사용됩니다. 대표적인 DCL 명령어로는 GRANT, REVOKE 등이 있습니다. 예를 들어, GRANT SELECT ON table_name TO user_name과 같은 문을 사용하여 특정 사용자에게 특정 테이블의 조회 권한을 부여할 수 있습니다. 

</details>



<details>
<summary>DBMS란?</summary><hr>

DBMS(Database Management System)는 데이터베이스를 관리하는 소프트웨어로,  
DBMS는 데이터의 조직화, 저장, 검색, 업데이트 및 관리 등을 담당합니다. 이를 통해 사용자가 데이터를 효율적으로 다룰 수 있도록 도와줍니다.  
DBMS는 데이터베이스의 구축, 관리, 보안, 백업 및 복원 등의 작업을 지원합니다. 이를 통해 사용자가 데이터를 안전하게 관리할 수 있도록 합니다.  
주로 Oracle, MySQL, Microsoft SQL Server 등이 널리 사용되고 있습니다.

</details>



<details>
<summary>DBMS의 기능은?</summary><hr>

DBMS의 기능은 매우 다양합니다.  
**(데이터 관리 및 검색)** 먼저, 데이터를 효율적으로 저장하고 관리하여 사용자가 쉽게 접근할 수 있도록 합니다.  
**(데이터 무결성 유지)** 또한, 데이터의 무결성과 일관성을 유지하고 보안을 강화하여 데이터의 안전성을 보장합니다.  
**(동시성 제어)** 동시에 여러 사용자가 데이터베이스에 접근할 때 발생할 수 있는 충돌을 방지하고,  
**(데이터 백업과 복원)** 데이터의 백업과 복원을 지원하여 데이터 손실을 예방합니다.  
이러한 기능들은 데이터베이스를 효율적으로 관리하고 안전하게 유지하는 데 중요한 역할을 합니다.

</details>



<details>
<summary>UML이란?</summary><hr>

UML(Unified Modeling Language)은 소프트웨어 시스템을 시각적으로 모델링하고 설계하기 위한 표준화된 언어입니다.   
UML은 다양한 다이어그램을 사용하여 시스템의 구조, 동작, 상호 작용을 표현하며, 소프트웨어 개발 과정에서 요구사항 분석, 설계, 구현, 테스트 등의 단계에서 활용됩니다.  
이는 시스템의 복잡성을 이해하고 문제를 해결하는 데 도움을 줄 뿐만 아니라, 팀 간의 의사 소통과 협업을 촉진하는 데에도 유용합니다.  
UML에는 클래스 다이어그램, 시퀀스 다이어그램, 액티비티 다이어그램 등이 있으며, 각각은 시스템을 특정 관점에서 표현합니다.

</details>



<details>
<summary>정규화란?</summary><hr>

정규화는 데이터베이스 설계 과정에서 중복을 최소화하고 데이터의 일관성을 유지하기 위해 데이터를 구조화하는 프로세스입니다.  
이는 테이블을 작은 단위로 분해하여 데이터 중복을 줄이고 관련성 있는 데이터를 분리합니다.  
주로 제1정규형, 제2정규형, 제3정규형 등의 단계를 거치며, 각각은 특정 종류의 중복을 제거하여 데이터베이스를 최적화합니다.  
이를 통해 데이터의 무결성을 보장하면서 데이터베이스의 성능을 향상시키는 데 도움을 줍니다.

</details>



<details>
<summary>정규화의 장단점?</summary><hr>

(장점) 정규화는 데이터 일관성을 향상시키고 중복을 줄여 데이터베이스의 효율성을 높일 수 있습니다. 또한, 데이터 변경 시 이상 현상을 감소시켜 유지 보수를 용이하게 합니다.   
(단점) 그러나 조인 연산이 증가하여 읽기 성능은 빨라지지만 쓰기 성능이 저하될 수 있으며, 데이터베이스의 구조가 복잡해질 수 있습니다.  
따라서, 적절한 정규화 수준을 유지하는 것이 중요합니다.

</details>



<details>
<summary>DB에서 View는 무엇인가? 가상 테이블이란?</summary><hr>

DB에서 **View**는 데이터베이스 테이블에 대한 쿼리 결과를 저장하지 않고도 사용자에게 제공하는 가상 테이블입니다. 
즉, View는 하나 이상의 기본 테이블로부터 데이터를 검색하거나 계산하여 동적으로 생성됩니다. 
이를 통해 사용자는 특정 데이터에 접근하고 쿼리할 수도 있으면서, 데이터를 실제로 복제하거나 저장하지 않아도 됩니다. 

**가상 테이블**은 데이터베이스에서 실제로 데이터를 저장하지 않고, 쿼리를 실행하여 생성되는 테이블입니다. 
즉, 가상 테이블은 데이터를 저장하지 않으면서도 쿼리 결과를 테이블 형태로 제공하는 객체입니다. 
이는 사용자가 특정한 조건에 맞는 데이터를 필터링하거나 특정 형태로 조직하여 조회할 수 있도록 돕습니다. 

</details>


<details>
<summary>이상현상이란?</summary><hr>
 
**이상 현상**은 데이터베이스에서 발생하는 비정상적인 상황을 말합니다. 
주로 데이터 중복이나 데이터의 불일치로 인해 발생하는데, 예를 들어 정보의 부분적 손실, 모순된 데이터 등이 이에 해당합니다. 
이러한 이상 현상은 데이터의 무결성을 저해하고 데이터베이스의 신뢰성을 훼손할 수 있습니다. 
따라서 이상 현상을 최소화하기 위해 정규화와 같은 데이터베이스 설계 기법이 사용됩니다.

</details>



<details>
<summary>이상현상의 종류?</summary><hr>

이상 현상의 종류에는 삽입 이상, 갱신 이상, 삭제 이상과 같이 일반적으로 세 가지 종류가 있습니다.  
**삽입 이상(Insertion Anomaly)은** 데이터를 삽입할 때 필요한 정보가 부족하거나 조건에 맞지 않아 발생하며,   
**갱신 이상(Update Anomaly)은** 중복된 데이터 중 일부만 업데이트되어 일관성이 깨지는 경우 발생합니다.   
**삭제 이상(Deletion Anomaly)은** 데이터를 삭제할 때 필요한 정보까지 함께 삭제되어 나중에 필요한 정보를 복구할 수 없게 되는 경우 발생합니다.  
이러한 이상 현상은 데이터베이스 설계 과정에서 정규화를 통해 최소화할 수 있습니다.

</details>



<details>
<summary>역정규화를 하는 이유?</summary><hr>

역정규화는 주로 읽기 작업의 성능을 향상시키기 위해 수행됩니다.   
특히 많은 수의 조인 연산이 발생하는 쿼리에서 성능을 개선하는데 사용됩니다.   
역정규화를 통해 자주 사용되는 데이터를 하나의 테이블로 결합하거나 인덱싱하여 읽기 작업의 복잡성을 줄이고 응답 시간을 단축할 수 있습니다.  
하지만 쓰기 작업에는 부정적인 영향을 줄 수 있으므로 적절한 균형을 유지하는 것이 중요합니다.

> **역정규화(denormalization)란?** 
<br> - 정규화를 통해 만든 테이블을 성능, 개발 편의성 등을 위해 조작하거나 구조를 바꾸는 것.
<br> - 정규화를 하게 되면 쓰기가 편리해지는 대신, 읽기의 성능을 희생하게 된다.
(테이블을 나누면 join을 해야 하는데, join에 드는 비용이 크기 때문)
<br> - 즉, 읽기가 자주 일어나는 테이블은 정규화로 인해 성능이 저하되는 경우가 있다. 이때 성능 향상을 위해 가장 마지막 수단으로 시도해볼 수 있는 것이 역정규화를 통한 구조 변경이다.
<br> - 그러나, 역정규화를 하기 전 반드시 정규화를 수행해야 한다. 아예 정규화를 수행하지 않은 테이블은 좋은 형태가 아니며, 정규화가 성능을 저하시킨다고 일반화할 수는 없기 때문이다.

</details>



<details>
<summary>데이터베이스를 설계할 때 가장 중요한 것이 무엇이라고 생각하나요?</summary><hr>


데이터베이스를 설계할 때 가장 중요한 것은 **데이터의 무결성과 일관성을 보장**하는 것입니다. 이를 위해서는  정확한 데이터 모델링과 구조화가 필요합니다.  
또한, 데이터베이스의 확장성과 성능을 고려하여 효율적인 구조를 갖추는 것도 중요합니다.    
마지막으로, 사용자의 요구사항을 충족시키면서도 보안 및 유지 보수성을 고려하여 안정적이고 신뢰할 수 있는 시스템을 구축하는 것이 중요합니다.

</details>



<details>
<summary>데이터베이스 무결성이란?</summary><hr>

데이터베이스 무결성은 데이터베이스 내의 데이터가 정확하고 일관성 있게 유지되는 것을 의미합니다.  
즉, 데이터베이스에 저장된 데이터가 정확한 형식과 값으로 유지되어야 하며, 데이터 간의 관계가 유지되어야 함을 의미합니다.  
이를 위해 데이터베이스는 데이터의 무결성을 위한 제약 조건을 설정하고, 이를 준수하는지 확인합니다.  
데이터베이스 무결성은 데이터의 신뢰성을 보장하고 데이터의 정확성을 유지하기 위해 중요한 개념입니다.

</details>



<details>
<summary>트리거란?</summary><hr>

트리거는 데이터베이스에서 특정 이벤트가 발생했을 때 자동으로 실행되는 작업입니다.  
이때, 이벤트란 데이터베이스 테이블에 삽입, 갱신, 삭제와 같은 데이터 조작 작업이 발생했을 때를 의미합니다.  
따라서, 트리거는 이러한 이벤트 발생 시 특정 작업이 수행되도록 설정할 수 있으며, 주로 데이터의 일관성을 유지하고 제약 조건을 강제하기 위해 사용됩니다.  
예를 들어, 특정 테이블의 행이 삭제될 때 관련된 다른 테이블에서도 자동으로 해당 행이 삭제되도록 하는 등의 작업을 수행할 수 있습니다.

</details>



<details>
<summary>Commit과 Rollback이란?</summary><hr>

Commit과 Rollback은 데이터베이스 트랜잭션에서 중요한 개념 2가지입니다.  
Commit은 트랜잭션이 성공적으로 완료되었을 때 데이터베이스에 모든 변경 사항을 영구적으로 반영하는 작업을 의미합니다. 이는 트랜잭션 내의 모든 작업이 성공적으로 수행되었음을 의미합니다.  
반면에 Rollback은 트랜잭션 도중에 문제가 발생하여 트랜잭션을 취소하고 이전 상태로 되돌리는 작업을 말합니다. 즉, Rollback은 트랜잭션이 실패하거나 오류가 발생했을 때 이전 상태로 복구하는데 사용됩니다.  
이 두 개념은 데이터베이스에서 데이터의 일관성과 무결성을 보장하는데 중요한 역할을 합니다.

</details>



<details>
<summary>SELECT 쿼리의 수행 순서를 알려주세요.</summary><hr>

SELECT 쿼리의 수행 순서는 다음과 같습니다:  
먼저 **FROM** 구문으로 데이터를 가져올 테이블이나 뷰를 지정하고, **WHERE** 구문으로 조건에 맞는 행을 필터링합니다.  
그 다음 **GROUP BY**로 특정 열을 기준으로 그룹화하고, **HAVING**으로 그룹화된 결과에 대한 조건을 지정합니다.  
**SELECT** 구문으로 가져올 열을 지정하고, 필요하다면 **DISTINCT**로 중복된 행을 제거합니다.  
마지막으로 **ORDER BY**로 결과를 정렬하여 최종 결과를 반환합니다.

> **SELECT 쿼리의 수행 순서** <br> 1. FROM: 데이터를 가져올 테이블이나 뷰를 지정합니다. <br> 2. WHERE: 지정된 조건에 맞는 행을 필터링합니다. <br> 3. GROUP BY: 특정 열을 기준으로 그룹화합니다. <br> 4. HAVING: 그룹화된 결과에 대한 조건을 지정하여 행을 필터링합니다. <br> 5. SELECT: 가져올 열을 지정합니다. <br> 6. DISTINCT: 중복된 행을 제거합니다. <br> 7. ORDER BY: 결과를 정렬합니다.

</details>



<details>
<summary>데이터 베이스에서 인덱스(색인)이란 무엇인가요, 장단점은?</summary><hr>

데이터베이스에서 인덱스(색인)는 데이터를 빠르게 찾을 수 있도록 돕는 데이터 구조입니다. 이는 특정 열에 대한 정렬된 키 값과 해당 키 값이 있는 데이터의 위치를 매핑하여 빠른 검색을 가능케 합니다.  
(장점) 인덱스는 검색 속도를 향상시켜 쿼리 응답 시간을 줄이고, 데이터 접근을 최적화하는 데 도움을 줍니다.  
(단점) 하지만 인덱스를 생성하면 데이터 삽입, 갱신, 삭제 작업의 성능이 저하될 수 있고, 적절하지 않은 인덱스는 오히려 성능을 저하시킬 수 있으므로 주의가 필요합니다.

</details>



<details>
<summary>RDBMS와 NoSQL의 차이에 대해 설명해주세요.</summary><hr>

RDBMS는 관계형 데이터베이스 시스템으로, 테이블 형태로 데이터를 저장하고 관리합니다. 데이터 모델은 엄격한 스키마를 따르며, ACID 트랜잭션을 지원하여 데이터 일관성을 보장합니다.  
반면에 NoSQL은 다양한 데이터 모델을 사용하며, 수평적 확장을 통해 대규모 데이터를 처리합니다. 스키마가 유연하고 BASE 모델을 따르며, 주로 대용량 데이터 저장과 실시간 처리에 적합합니다.

> RDBMS와 NoSQL은 데이터 모델, 확장성, 일관성,  스키마, 주요 용도 측면에서 다음과 같은 차이점이 존재합니다. 
> 1. **데이터 모델**:
RDBMS는 관계형 데이터 모델을 사용하여 데이터를 테이블 형식으로 저장합니다. 테이블은 열과 행으로 구성됩니다.
NoSQL은 다양한 데이터 모델을 사용합니다. 주로 키-값, 문서, 열 지향, 그래프 등의 데이터 모델을 지원합니다.
> 2. **확장성**:
RDBMS는 주로 수직적 확장을 지원하며, 단일 서버에서 성능을 향상시키는 방식으로 확장됩니다.
NoSQL은 주로 수평적 확장을 지원하며, 여러 서버에 데이터를 분산하여 확장됩니다.
> 3. **일관성**:
RDBMS는 ACID 트랜잭션을 지원하여 데이터 일관성을 보장합니다.
NoSQL은 BASE(기본적 가용성, 약한 일관성, 분산된 상태)를 따르며, 데이터의 일관성과 가용성 사이에 균형을 유지합니다.
> 4. **스키마**:
RDBMS는 정형화된 스키마를 사용하며, 데이터 구조가 변경되면 스키마를 수정해야 합니다.
NoSQL은 유연한 스키마를 사용하여 데이터 모델의 변경이 용이합니다.
> 5. **주요 용도**:
RDBMS는 OLTP(온라인 트랜잭션 처리) 및 OLAP(온라인 분석 처리)과 같은 전통적인 응용 프로그램에 적합합니다.
NoSQL은 대용량 데이터 저장 및 실시간 데이터 처리와 같은 대규모 분산 시스템에 적합합니다.

</details>



<details>
<summary>트랜잭션이란 무엇인지 설명해주세요.</summary><hr>

트랜잭션은 데이터베이스에서 한 번에 수행되어야 하는 작업들을 묶은 논리적인 단위입니다.  
트랜잭션은 "원자성(Atomicity)", "일관성(Consistency)", "고립성(Isolation)", "지속성(Durability)"의 ACID 속성을 보장합니다. 즉, 모든 작업이 성공하면 데이터베이스가 변경사항을 반영하고, 실패하면 이전 상태로 롤백됩니다. 이러한 트랜잭션의 원자성을 통해 데이터베이스의 안전성과 무결성을 보장합니다. 

</details>



<details>
<summary>트랜잭션의 특성(ACID)에 대해 설명해주세요. & 트랜잭션의 원자성에 대해 설명해주세요.</summary><hr>

트랜잭션의 ACID 특성은 원자성, 일관성, 고립성, 지속성으로 이루어져 있습니다.  
1. **원자성(Atomicity)**: 트랜잭션은 "모두 실행되거나 아무것도 실행되지 않아야" 합니다. 즉, 트랜잭션 내의 모든 작업은 원자적으로 처리되어야 하며, 중간에 실패하면 롤백되어 이전 상태로 복구됩니다.
2. **일관성(Consistency)**: 트랜잭션의 수행 후 데이터베이스는 일관된 상태여야 합니다. 즉, 트랜잭션 전후에 데이터베이스는 일관성 있는 상태를 유지해야 합니다.
3. **고립성(Isolation)**: 동시에 여러 트랜잭션이 수행될 때 각 트랜잭션은 다른 트랜잭션에 영향을 받지 않아야 합니다. 즉, 한 트랜잭션이 완료되기 전에 다른 트랜잭션의 결과를 볼 수 없어야 합니다.
4. **지속성(Durability)**: 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 저장되어야 합니다. 시스템에 장애가 발생하더라도 데이터베이스에 기록된 변경 사항은 유지되어야 합니다.

</details>



<details>
<summary>트랜잭션을 사용할 때 주의해야 할 점은 무엇인가요?</summary><hr>

트랜잭션을 사용할 때 주의해야 할 점은 다음과 같습니다:
1. **트랜잭션 범위**: 트랜잭션 범위를 최소화하여 트랜잭션이 실행되는 시간을 최소화해야 합니다. 긴 트랜잭션은 데이터베이스 락을 오랫동안 유지하여 다른 트랜잭션의 처리를 방해할 수 있습니다.
2. **데이터베이스 락**: 트랜잭션이 데이터를 업데이트할 때 다른 트랜잭션이 해당 데이터에 접근하지 못하도록 데이터베이스 락이 걸리므로, 락 충돌을 최소화해야 합니다.
3. **예외 처리**: 트랜잭션 내에서 예외가 발생할 수 있는 경우, 이를 적절하게 처리하여 트랜잭션이 롤백되거나 복구될 수 있도록 해야 합니다.
4. **트랜잭션 경계**: 트랜잭션 경계를 명확하게 설정하여 여러 작업을 단일 트랜잭션으로 묶지 않는 것이 중요합니다. 이는 트랜잭션의 원자성을 보장하고 트랜잭션의 지속성을 유지하는 데 도움이 됩니다.
5. **트랜잭션 관리**: 트랜잭션을 효율적으로 관리하여 데이터베이스 리소스를 효율적으로 활용해야 합니다. 이는 트랜잭션의 수행 시간을 최소화하고 데이터베이스 성능을 향상시키는 데 도움이 됩니다.

</details>



<details>
<summary>트랜잭션을 병행으로 처리(동시성 제어)하려고 할 때 발생할 수 있는 문제를 설명해보시오.</summary><hr>

**Q1. 트랜잭션을 병행으로 처리(동시성 제어)하려고 할 때 발생할 수 있는 문제를 설명해보시오.**  
트랜잭션을 병행으로 처리하려고 할 때 잃어버린 갱신, 모순된 읽기, 파라미터 변경, 균형 손실 등 여러 문제가 발생할 수 있습니다.   
<u>잃어버린 갱신(lost update)</u>과 <u>모순된 읽기(dirty read)</u>는 데이터 일관성을 해칠 수 있는 문제로, 둘 다 여러 트랜잭션이 동시에 데이터를 변경하거나 읽을 때 발생할 수 있습니다.   
또한 <u>파라미터 변경(parameter inconsistency)</u>과 <u>균형 손실(phantom read)</u>은 트랜잭션이 동시에 실행되는 동안 데이터베이스의 상태가 변경될 때 발생할 수 있는 문제입니다.

> 1. 잃어버린 갱신(lost update): 두 트랜잭션이 같은 데이터를 동시에 수정할 때, 하나의 수정이 다른 것을 덮어쓰는 문제가 발생할 수 있습니다. 
> 2. 모순된 읽기(dirty read): 한 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 변경 내용을 읽을 때, 일시적으로 부정확한 데이터를 읽을 수 있습니다.
> 3. 파라미터 변경(parameter inconsistency): 한 트랜잭션이 실행 중인 동안 다른 트랜잭션이 관련된 파라미터 값을 변경하는 경우, 원하지 않는 결과를 초래할 수 있습니다.
> 4. 균형 손실(phantom read): 한 트랜잭션이 동일한 쿼리를 실행하는 동안 다른 트랜잭션이 데이터를 추가, 삭제 또는 수정하는 경우, 일관성 없는 결과를 얻을 수 있습니다.

**Q2. 트랜잭션을 병행으로 처리할 때 위와 같은 문제를 방지하기 위한 방법을 설명하시오.**  
이러한 문제를 방지하기 위한 방법으로는 주로 <u>잠금(locking)</u>을 사용합니다.  
잠금은 트랜잭션 간의 충돌을 방지하고 데이터 일관성을 유지하는 데 도움을 줄 수 있습니다.  
잠금 수준을 조절하여 최소한의 락을 획득하고 최대한의 병행성을 유지할 수 있습니다.

**Q3. 그렇다면 이 로킹 단위를 크게했을 때와 작게 했을 때의 차이점을 설명하시오.**  
<u>로킹 단위를 크게하면</u> 한 번에 많은 양의 데이터를 잠그므로 더 많은 트랜잭션을 동시에 처리할 수 있지만, 락 경합이 줄어들 수 있습니다.  
반면에 <u>작은 로킹 단위</u>는 각 트랜잭션당 필요한 데이터만을 잠그므로 더 높은 병행성을 제공하지만, 락 경합이 더 자주 발생할 수 있습니다.  
> 하지만 큰 로킹 단위는 데이터베이스 전체를 잠그는 것이 아니라 해당 단위를 잠그는 것이기 때문에 일부 트랜잭션의 병행성이 제한될 수 있습니다.

**Q4. 로킹 제어가 일으킬 수 있는 문제점은 무엇인가?**  
로킹 제어가 일으킬 수 있는 문제점으로는 <u>데드락(deadlock), 락 경합으로 인한 성능 저하, 그리고 로킹의 과도한 사용으로 인한 교착 상태(stalemate)</u>가 있습니다.   
이러한 문제를 피하기 위해 효율적인 로킹 전략과 적절한 격리 수준 설정이 필요합니다.

> 1. 데드락(deadlock): 두 개 이상의 트랜잭션이 서로 상대방이 소유한 락을 기다리며 서로의 작업을 끝내지 못하는 상황이 발생할 수 있습니다.
> 2. 락 경합(lock contention): 여러 트랜잭션이 동시에 같은 자원에 접근하여 락을 얻기 위해 경합하는 경우가 있을 수 있습니다. 이는 성능 저하를 초래할 수 있습니다.
> 3. 교착 상태(stalemate): 두 개 이상의 트랜잭션이 락을 획득하고 다른 트랜잭션의 락을 기다리는 상태로, 모든 트랜잭션이 작업을 완료하지 못하고 대기 상태에 머무를 수 있습니다.
> 4. 로킹의 과도한 사용: 너무 많은 락이 설정되면 데이터베이스의 성능이 저하될 수 있습니다.

</details>



<details>
<summary>격리 수준 중 SERIALIZABLE에 대해 설명해주세요.</summary><hr>

SERIALIZABLE 격리 수준은 가장 엄격한 격리 수준으로, 트랜잭션들이 순차적으로 실행되는 것처럼 보이는 것을 의미합니다. 이는 동시에 실행되는 트랜잭션 간의 간섭이 없다는 것을 의미하기도 합니다.  
즉, 한 트랜잭션이 다른 트랜잭션의 변경 사항을 읽을 수 없으며, 다른 트랜잭션도 해당 트랜잭션의 변경 사항을 읽을 수 없습니다.  
이러한 격리 수준은 데이터베이스 시스템의 복잡성을 줄이고 일관성을 유지하기 위해 사용됩니다.  
그러나 SERIALIZABLE 격리 수준은 성능에 부정적인 영향을 미칠 수 있으며, 데드락이 발생할 가능성도 있습니다.

> 격리 수준이란? <br>
> 격리 수준은 데이터베이스에서 트랜잭션 간의 상호 작용을 제어하는 수준을 말합니다. 즉, 하나의 트랜잭션이 다른 트랜잭션에 얼마나 많은 정보를 노출하고 허용하는지를 결정합니다. 격리 수준이 높을수록 트랜잭션 간의 간섭이 적고 데이터 일관성이 더 보장되지만, 성능에 영향을 줄 수 있습니다. 대표적인 격리 수준으로는 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE이 있습니다.

</details>



<details>
<summary>DB 락에 대해 설명해주세요.</summary><hr>

데이터베이스 락은 여러 트랜잭션이 데이터에 동시에 접근하는 것을 제어하는 메커니즘입니다.  
이를 통해 트랜잭션은 데이터를 안전하게 읽고 쓸 수 있으며, 데이터의 무결성을 보존할 수 있습니다.  
일반적으로 읽기 락과 쓰기 락이 있으며, 읽기 락은 여러 트랜잭션이 동시에 데이터를 읽을 수 있지만, 쓰기 락은 한 번에 하나의 트랜잭션만이 데이터를 수정할 수 있도록 합니다.  

</details>



<details>
<summary>데드락에 대해서 설명해보세요.</summary><hr>

데드락은 두 개 이상의 트랜잭션이 서로가 가진 락을 얻기 위해 무한히 대기하는 상황을 가리킵니다.  
이러한 상황에서는 각 트랜잭션이 다른 트랜잭션에서 보유한 락을 얻기 위해 대기하고 있기 때문에 둘 이상의 트랜잭션이 계속해서 진행하지 못하고 막히게 됩니다.  
데드락 상태를 해결하기 위해서는 트랜잭션 중 하나가 롤백되거나 시스템 관리자의 개입이 필요할 수 있습니다.

</details>



<details>
<summary>그럼 데드락을 안 생기게 하는 방법을 설명해보시오.</summary><hr>

데드락을 방지하기 위한 여러 가지 방법이 있습니다:
1. **자원의 일괄적인 할당**: <u>모든 트랜잭션이 필요로 하는 자원을 미리 할당해주는 방법</u>입니다. 이를 통해 한 번에 하나의 트랜잭션만이 자원을 사용하고, 데드락을 방지할 수 있습니다.
2. **자원에 대한 순서화**: <u>트랜잭션이 여러 자원을 요청할 때, 일정한 순서로 자원을 요청하도록 강제하는 방법</u>입니다. 이를 통해 트랜잭션 간의 경쟁이 발생하지 않고 데드락을 예방할 수 있습니다.
3. **타임아웃 설정**: <u>트랜잭션이 특정 자원을 얻지 못한 채로 일정 시간이 지나면 해당 트랜잭션을 롤백하는 방법</u>입니다. 이를 통해 데드락에 빠진 트랜잭션을 감지하고 처리할 수 있습니다.
4. **데드락 검출 및 해결**: <u>데드락이 발생했을 때 시스템이 이를 감지하고, 트랜잭션 중 하나를 롤백하여 데드락을 해결하는 방법</u>입니다. 이를 위해 주기적으로 데드락을 검사하는 알고리즘을 구현할 수 있습니다.

</details>



<details>
<summary>JDBC와 ODBC의 차이는?</summary><hr>

JDBC(Java Database Connectivity)와 ODBC(Open Database Connectivity)는 모두 데이터베이스에 접근하기 위한 API(응용 프로그래밍 인터페이스)이지만,   
`언어` JDBC는 자바 언어를 위한 것이고, ODBC는 C나 C++과 같은 언어를 위한 것입니다.  
`플랫폼 종속성` JDBC는 자바 플랫폼에 종속되어 있고, ODBC는 주로 Windows 플랫폼에 종속되어 있습니다.  
`구현 방식` JDBC는 자바로 작성된 드라이버를 사용하여 데이터베이스와 통신하며, ODBC는 C로 작성된 드라이버를 사용합니다.  
`사용 범위` 이러한 차이점으로 JDBC는 주로 자바 애플리케이션에서 사용되고, ODBC는 C나 C++ 애플리케이션에서 사용됩니다.

> +) `성능` 일반적으로 JDBC가 ODBC보다 성능이 우수합니다. 이는 JDBC가 자바 플랫폼에 특화되어 있고, 자바 가상 머신(JVM)에서 바로 실행될 수 있기 때문입니다.

</details>



<details>
<summary>커넥션 풀을 사용하는 이유와 장점 그리고 주의점</summary><hr>

**커넥션 풀이란?**  
커넥션 풀은 데이터베이스 연결을 관리하기 위한 메커니즘으로, 여러 개의 미리 설정된 연결을 풀에 보관하고 필요할 때 사용합니다.

**커넥션 풀을 사용하는 이유 및 장점**  
커넥션 풀을 사용하는 이유는 주로 성능 향상과 자원 관리에 있습니다.  
풀을 통해 미리 생성된 연결을 재사용하면 연결 생성 오버헤드를 줄이고 응답 시간을 단축할 수 있습니다(+ 애플리케이션의 안전성 향상).  
또한, 풀을 통해 연결을 관리하면 시스템 리소스를 효율적으로 활용하고 애플리케이션의 확장성을 높일 수 있습니다.

**커넥션 풀을 사용할 때의 주의점**  
커넥션 풀을 사용할 때 주의해야 할 사항은 다음과 같습니다.  
먼저, 풀의 크기를 적절하게 설정하는 것이 중요합니다. 너무 큰 풀은 메모리를 낭비할 수 있고, 너무 작은 풀은 동시에 처리할 수 있는 요청 수를 제한할 수 있습니다.  
그리고 애플리케이션에서 커넥션을 반환하지 않고 계속 유지하는 경우 리소스 누수가 발생할 수 있으므로, 모든 연결은 사용 후 반드시 반환되어야 합니다.  
다음으로, 풀에서 대기 중인 연결이 오래되면 연결이 손상될 수 있으므로, 대기 시간을 적절하게 관리해야 합니다.  
마지막으로, 여러 스레드에서 동시에 커넥션을 사용할 때 스레드 간의 충돌이 발생하지 않도록 적절한 동시성 제어가 필요합니다.

</details>



<details>
<summary>어떤 상황에서 NoSQL을 쓰는 것이 더 적합한가?</summary><hr>

대규모 데이터의 저장 및 처리가 필요한 경우,  
데이터의 구조가 유연하고 확장성이 중요한 경우,  
분산 시스템에서의 데이터 관리가 필요한 경우,  
빠른 데이터 처리 속도와 높은 가용성이 요구되는 경우에  
NoSQL을 사용하면 관계형 데이터베이스보다 더 효과적으로 요구사항을 충족시킬 수 있습니다.

</details>



<details>
<summary>CAP 이론에 대해 설명해주세요.</summary><hr>

CAP 이론은 분산 시스템에서 일관성(Consistency), 가용성(Availability), 그리고 분할 내성(Partition Tolerance) 중에서 두 가지만 선택할 수 있다는 이론입니다. 이는 시스템이 네트워크 문제 등으로 인해 세 가지 속성 모두를 동시에 만족할 수 없음을 의미합니다. 따라서 시스템 설계 시 이 세 가지 속성을 어떻게 조절할지 결정해야 합니다. 예를 들어, 분할 내성을 보장하기 위해 일관성이나 가용성을 희생하는 등의 선택이 필요합니다.

</details>



<details>
<summary>OLTP, OLAP에 대해 설명해주세요.</summary><hr>

**OLTP(Online Transaction Processing)는 실시간으로 데이터를 처리하고 관리하는 시스템**입니다. 주로 일상적인 비즈니스 작업에 사용됩니다. 예를 들어, 은행 거래, 예약 시스템, 주문 처리 등과 같은 트랜잭션 처리에 적합합니다. OLTP 시스템은 대량의 데이터를 추가, 수정, 삭제하며 실시간으로 데이터베이스를 업데이트하여 효율적인 작업을 지원합니다. 이러한 작업은 데이터의 정확성과 신뢰성이 중요한 상황에서 사용됩니다.

**OLAP(Online Analytical Processing)는 데이터를 분석하고 질의하는 시스템**입니다. 대규모 데이터 세트에서 다차원 분석, 집계, 데이터 마이닝 등을 수행합니다. 주로 의사 결정 지원 시스템에서 사용되며, 데이터를 심층적으로 분석하여 비즈니스 인텔리전스를 도출하는 데 중요한 역할을 합니다. OLAP 시스템은 사용자가 데이터를 다양한 관점에서 살펴볼 수 있도록 지원하며, 통찰력을 얻고 향상된 의사 결정을 내릴 수 있도록 돕습니다.

</details>



<details>
<summary>ETL에 대해 설명해주세요.</summary><hr>

ETL은 Extract, Transform, Load의 약어로, 데이터 웨어하우스나 데이터베이스에 추출(Extract), 변환(Transform), 로드(Load)하는 프로세스를 의미합니다.  
먼저, **Extract 단계**에서는 다양한 데이터 원본에서 필요한 데이터를 추출합니다.  
그 다음, **Transform 단계**에서는 추출된 데이터를 필요한 형식으로 변환하고 정제합니다.   
마지막으로, **Load 단계**에서는 변환된 데이터를 데이터 웨어하우스나 데이터베이스에 로드하여 저장합니다.   
이러한 과정을 통해 사용자는 데이터를 분석하고 의사 결정을 내리는 데에 필요한 정보를 얻을 수 있습니다.  
따라서, ETL 프로세스는 데이터 통합 및 데이터 마이그레이션에 필수적이며, 비즈니스 인텔리전스 및 데이터 분석에 필요한 기반을 제공합니다.

</details>


